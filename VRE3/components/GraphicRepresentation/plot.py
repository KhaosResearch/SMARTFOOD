import math
import zipfile
from pathlib import Path

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import typer
from plotly.subplots import make_subplots


def plot(
    fitness_evolution_file: Path = typer.Option(
        ...,
        help="Fitness evolution file generated by smartfood epanet optimization component",
    ),
    fun_file: Path = typer.Option(
        ...,
        help="File with function values generated by smartfood epanet optimization component",
    ),
    output_zip_file: Path = typer.Option(..., help="Output zip file name"),
):

    # Instantiate the output zip file
    z = zipfile.ZipFile(output_zip_file, "w", zipfile.ZIP_DEFLATED)

    # Open the file with the fitness values
    f = open(fitness_evolution_file, "r")

    # Each line contains the evolution of a different objective
    lines = f.readlines()

    # Create grid for graphs
    if len(lines) == 1:
        r = 1
        c = 1
    elif len(lines) == 2:
        r = 1
        c = 2
    else:
        r = math.ceil(len(lines) / 2)
        c = 2

    # Get titles from fun_file
    objectives = pd.read_csv(fun_file, nrows=0).columns.tolist()

    # Make plots
    fig = make_subplots(rows=r, cols=c, subplot_titles=objectives)

    # For each objective ...
    for i in range(len(lines)):

        # Read the evolution of its values
        str_fitness = lines[i].split(", ")

        # Convert it to the appropriate type (float)
        fitness = [float(v) for v in str_fitness]

        # Get row and column index
        curr_row = math.ceil((i + 1) / c)
        curr_col = (i + 1) - (c * (curr_row - 1))

        # Plot it under the label of its function
        fig.add_trace(
            go.Scatter(x=list(range(len(fitness))), y=fitness),
            row=curr_row,
            col=curr_col,
        )
        fig.update_xaxes(title_text="Generation", row=curr_row, col=curr_col)
        fig.update_yaxes(title_text="Fitness", row=curr_row, col=curr_col)

    # Customize and save the figure
    fig.update_layout(title_text="Fitness evolution", showlegend=False)
    filename = fitness_evolution_file.with_suffix(".html")
    fig.write_html(filename)
    z.write(filename)
    Path(filename).unlink()

    # If there is more than one objective we paint the graph of parallel coordinates
    if len(lines) > 1:

        # Open the file with the fitness values associated with the non-dominated solutions.
        f = open(fun_file, "r")

        # Each line contains the fitness values of a solution of the pareto front.
        lines = f.readlines()

        # Create pandas dataframe
        df = pd.DataFrame(columns=objectives)

        # For each solution add its fitness values to the dataframe
        del lines[0]
        for i, line in enumerate(lines):
            df.loc[len(df.index)] = [float(v) for v in line.split(",")]

        # If there are two objectives the pareto front is plotted
        if len(lines) == 2:
            ## Get columns as lists
            fitness_o1 = df[objectives[0]].tolist()
            fitness_o2 = df[objectives[1]].tolist()

            ## Obtain the order corresponding to the first objective in order to plot the front in an appropriate way.
            sorted_idx = np.argsort(fitness_o1)

            ## Sort all vectors according to the indices obtained above.
            fitness_o1 = [fitness_o1[i] for i in sorted_idx]
            fitness_o2 = [fitness_o2[i] for i in sorted_idx]

            # Plot, customize, save the figure
            fig = px.line(
                x=fitness_o1, y=fitness_o2, markers=True, title="Pareto front"
            )
            fig.update_xaxes(title_text=objectives[0])
            fig.update_yaxes(title_text=objectives[1])
            filename = "pareto_front.html"
            fig.write_html(filename)
            z.write(filename)
            Path(filename).unlink()

        # We paint the graph of parallel coordinates
        fig = px.parallel_coordinates(
            df, dimensions=objectives, title="Graph of parallel coordinates"
        )
        filename = (
            str(fitness_evolution_file.with_suffix("")) + "_parallel_coordinates.html"
        )
        fig.write_html(filename)
        z.write(filename)
        Path(filename).unlink()

    # Close output zip file
    z.close()


if __name__ == "__main__":
    typer.run(plot)
